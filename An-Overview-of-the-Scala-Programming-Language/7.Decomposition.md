7	解构（Decomposition）
7.1	面向对象的解构模式（Object-Oriented Decomposition）
处理结构化数据是程序设计很重要的一项工作，在面向对象的语言中，结构化数据通常都用一系列不同结构的类来实现，开发者一般通过调用这些类的各种虚拟方法来访问类内部的数据。
我们看一个例子：针对仅包含加法的代数项（algebraic term）求值。采用面向对象的模式，我们可以根据一个代数项的结构进行解构来实现：

abstract class Term {
def eval: int
}
class Num(x: int) extends Term {
def eval: int = x
}
class Plus(left: Term, right: Term) extends Term {
def eval: int = left.eval + right.eval
}
这段代码用Term类来表示一个代数项，包含一个eval方法，Term的具体子类可以实现不同类型的代数项，每一个具体的子类必须给出eval方法的具体实现。

这种面向对象的解构模式要求人们预先知道一个数据结构的全部访问方式，这样一来，即使是一些内部方法有时也需要暴露出来。为这些类增加新方法往往是无聊且容易出错的，因为几乎所有的类都要被改写或者继承。另一个问题是，各种操作的实现散落在所有这些类中，不利于人们理解和修改。

7.2	模式匹配替代类层次结构（Pattern Matching Over Class Hierarchies）
上面的代码是一个很好的例子，用于展现函数式解构模式优于面向对象解构模式的场景。在函数式语言中，人们一般将数据结构及其上的操作分开来定义，数据结构通常用代数类型来定义，而操作则定义为普通函数，通过模式匹配来实现对数据结构的操作，这是函数是语言的基本解构原则。这种方式可以让人们仅仅实现eval函数，而无需暴露那些人工的辅助函数。

Scala提供了一套很自然的方式来用函数式编程模型来完成上述工作，让开发者够定义代数式的结构化结构类型，从而能采用基于模式匹配的解构模式。Scala没有在语言层面增加代数式数据类型，而是通过类的抽象机制层面的强化，来简化结构化数据的构造：一个增加了case描述符的类，自动定义了一个工厂方法，这个方法的参数与类的构造方法一致。同时，Scala引入了一种机制，可以将case class的构造方法作为模式匹配表达式的匹配模式。
采用case class实现的代数项计算方式如下：
abstract class Term
case class Num(x: int) extends Term
case class Plus(left: Term, right: Term) extends Term
在此基础上，类似1+2+3这样的表达式，可以无需使用new操作，而是直接采用case class的构造方法：
Plus(Plus(Num(1), Num(2)), Num(3))
Scala的模式匹配表达式提供了将case class的构造方法作为模式的手段，采用模式匹配实现的eval方法如下：
object Interpreter {
def eval(term: Term): int = term match {
case Num(x) => x
case Plus(left, right) => eval(left) + eval(right)
}
}

其中的模式匹配表达式：“x match { case pat1 => e1 case pat2 => e2 ...}”将x与模式 pat1、pat2按顺序进行匹配。上述代码中采用了Constr(x1,…,xn)形式的模式，Constr表示一个case class的构造函数，xi表示一个变量。一个对象如果是某个拥有对应的构造函数的case class实例，则与对应的模式相匹配。同时，匹配过程针对相应的变量进行实例化，而后执行匹配结果对应的右侧的表达式。
这种解构模式的优势就在于可以很容易地在系统中增加新的函数。当然，另一方面，引入一个新的case class也可能会引起所有模式匹配表达式的修改。此外，模式匹配还可以进行嵌套，例如可以定义：case Plus(x, y) if x == y => ...，这样就能仅匹配x=y的情况，也就是说只有形如t+t的表达式才执行对应的计算。这个方式又叫“守护”（patterns with guards）模式，顾名思义，x、y相等通过x==y这个模式来保证。
