##10 相关研究（Related Work）##

Scala的设计受到多种语言及相关论文的影响，下面列出的是对Scala的设计产生主要影响的一些相关研究。

显而易见地，Scala从Java[23]和C#[15]中吸收了大量概念和语法约定。Scala表达属性的方式，大致借鉴了Sather语言[44]的模型。Scala的统一对象模型，主要来自于SmallTalk [22]的概念。从Beta[30]语言中， Scala借鉴了一切皆可嵌套的理念，包括类。Scala的混入模型设计，主要来自于面向对象的线性混入[6]，但是将混入式构成定义成为对称模式，更接近于[14, 25,49]中定义的混入模块，或者traits[42]。 Scala的抽象类型定义非常接近ML[24] 和OCaml[29]当中模块体系的抽象类型签名，但将其进一步泛化成一等语法组件。 For-comprehensions是基于Haskell的monad comprehensions[46]，尽管语法上更接近XQuery[3]。视图主要是借鉴Haskell的type classes[47]，可以看做是面向对象版本的类型化type classes[38]，不过却更具通用性，因为其实例的声明是有范围的/局部的。 在动态类型系统里，视图的主要好处来自于Classbox的概念，不过Classbox比视图更强大，允许本地重绑定，从而可以通过动态指派来选择类的特定扩展。

某种意义上讲，Scala是Pizza语言[37]相关工作的一个延续（Pizza也是Odersky发明的语言，接近于是Scala前身——译注）。和Pizza一样，Scala编译后在JVM上运行，增加了高阶函数，泛型和模式匹配等函数式编程的构造。 区别之处在于Pizza还向后兼容Java，而Scala的目标则是只保留互操作性，这样在设计方面就有更大的自由度。

Scala的目标是为组件的抽象和构成提供先进的语法构造，这一点在很多最近的研究中也都有体现。抽象类型就相当于gbeta[16, 17]中虚拟类（virtual classes）的一个保守实现，提供了其带来的大部分好处。 类似的还有FamilyJ[40]中的代理层，以及[32]中提出的Java的嵌套继承等。Jiazzi[31]是Java的一个扩展，提出了基于单元的模块化机制，这是一个强大的参数化模块形式的实现。 Jazzi支持类似于Scala的语法扩展方式，例如实现minxin的能力。

Nice语言[4]也是最近出现的一个类似于Scala的语言，但是从ML<sub><=</sub>5继承了一些内容。Nice包含了多路指派（multiple dispatch）、开放类（open classes）以及一个基于抽象接口实现的受限形态的可追溯抽象模式。Nice不支持模块化的实现阶段类型检查。Nice和Scala虽然都与Java有很大差异，但都被设计为与Java程序和类库具有互操作性，并且也都编译成JVM上执行。

MultiJava[13]是一个Java的保守扩展，也增加了对称多路指派和开放类。 他采用了很多不同的解决方案来实现Scala解决的问题。例如：多路指派就解决了二元操作方法的问题，而Scala是通过抽象类型解决的。又如开放类则解决了外部可扩展性问题，而Scala使通过视图来解决的。 MultiJava可以动态为一个类增加新方法，这是因为开放类是基于Java的动态装载机制实现的，这一点是Scala所没有的。 反过来，也只有Scala才支持对类的外部扩展限定可见范围。

OCaml和Moby[20]是另外两个将函数式和面向对象模式进行整合的静态类型语言。与Scala不同之处在于，这两种语言都是基于一套丰富的函数式编程语言和复杂的模块化系统，然后建立起相对轻量级的对象体系。
